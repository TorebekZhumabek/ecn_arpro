\documentclass{ecnreport}

\stud{EMARO-ARIA}
\topic{Advanced Robot Programming}

\begin{document}

\inserttitle{Advanced Robot Programming  Labs \newline C++ Programming}

\insertsubtitle{Lab 1: Open projects}


\section{Content of this lab}

The goal of the first C++ labs are to learn C++ by building your own project.
Several small projects are listed below and you are encouraged to try and build several of them. Many of them can be done without using evolved concepts of C++.

You are encouraged to use functions, classes or even templates if you think it will lead to a better code that is easier to understand and to write.
You are also encouraged to separate your code in several files. If you are not sure about classes or functions, you can always change it later and compare
the same program with different code designs.

You may look for mathematical solutions, problem formulation or problem variations on Internet, but of course the actual code should come from yourselves.

\subsection{How to compile}

We use CMake tools to compile our projects.
The content of the CMakeLists.txt file should follow the structure of your code directory (or preferably sub-directory):
The structure of your code directory (or sub-directory should be like:
\begin{center}
\begin{minipage}{.4\linewidth}
 \dirtree{%
.1 MyProject. 
.2 include.
.3 a\_class.h.
.3 some\_functions.h.
.3 a\_basic\_header.h.
.2 src.
.3 main.cpp.
.3 a\_class.cpp.
.3 some\_functions.cpp.
.2 CMakeLists.txt.
} 
\end{minipage}
\begin{minipage}{.5\linewidth}\cppstyle
\begin{lstlisting}
cmake_minimum_required (VERSION 2.6)
project (MYPROJECT)

add_compile_options(-std=c++11)

include_directories(include)

add_executable(mygame 
  src/main.cpp include/a_basic_header.h
  include/a_class.h a_src/class.cpp
  include/some_function.h src/some_function.cpp)
\end{lstlisting} \end{minipage}
\end{center}

The CMake file is used to generate a Makefile. The steps are:
\begin{enumerate}
 \item Create a build directory: \texttt{mkdir build}
 \item Go inside: \texttt{cd build}
 \item Call CMake: \texttt{cmake ..}
 \item Call Make: \texttt{make}
 \item Then launch your program: \texttt{./mygame}
\end{enumerate}


\section{Single player games}

In the single player games, the opponent is the computer which plays with a basic or advanced AI depending on your programming
motivation (and game AI possibilities...).


\subsection{Find the number}

Here both the players start by giving a number between 1 and 100 to the computer. Then they try to find the number of the other player
in a minimum number of turns.

\begin{itemize}
 \item This game involves: Input/output
 \item AI tips: Random numbers depend on seed
\end{itemize}

\subsection{Rock-paper-scissors}

The player is asked to choose between rock, paper or scissors. The computer also does a choice and the winner depends on the two choices:
\begin{itemize}
 \item Rock beats Scissors
 \item Paper beats Rock
 \item Scissors beats Rock
 \item Draw in the case of equal choices
\end{itemize}


\begin{itemize}
 \item This game involves: Input/output, Random numbers
  \item AI tips: none, this game is completely random
\end{itemize}

\section{Turn-based text games}

In these two-player games, the players play one at a time. The goal is usually to reach the winning situation before the other.
They can also be programmed to play against an artificial intelligence. This time the AI can be much more complex than for the first games.

\subsection{21 sticks game}

In this game, a given umber of sticks (typically 21) are displayed.
Each player has to pick up 1 to 3 sticks, then the other player can pick up his sticks.
The goal is not to have to pick the last stick.

\begin{itemize}
 \item This game involves: Input/output
 \item AI tips: If you can start correctly you may never lose.
\end{itemize}

\subsection{Battleship}

In this game each player has a number of boats that are placed on a 10$\times$10 grid. The goal is to sink all the opponent's boats.
Each player begins by placing their boats according to the following:
\begin{itemize}
 \item One Aircraft carrier [A] of length 5
 \item One Cruiser [C] of length 4
 \item One Destroyer [D] of length 3
 \item One Submarine [S] of length 3
 \item One Minesweeper [M] of length 2
\end{itemize}

The player grids may be entered manually or with a text file (check grid consistency), or randomly generated.
Each player then enters coordinates of the targeted grid cell. A boat can be hit, sunk or it may be a miss. 

The current grids should be displayed with:
\begin{itemize}
 \item A dot for a non-targeted cell
 \item A cross for missed shots
 \item The boat letter for hit or sunk boats
\end{itemize}

\begin{center}
 \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|}
 \hline 
 & 0 & 1 & 2& 3&4 &5 &6 & 7&  8&9 \\\hline
 0 &x&.&.&. &.& .&.&.&.&.\\\hline
 1 &.&.&.&. &C&C&x&.&.&.\\\hline
 2 &.&x&.&. &.&.&.&M&.&.\\\hline
 3 &.&.&.&. &.&.&.&.&.&.\\\hline
 4 &.&.&.&. &.&.&.&.&.&.\\\hline
 5 &.&.&x&. &A&A&A&A&A&.\\\hline
 6 &.&.&.&. &.&.&.&.&.&.\\\hline
 7 &.&.&.&. &.&.&.&.&.&.\\\hline
 8 &.&.&.&. &.&.&.&x&.&.\\\hline
 9 &.&.&.&. &.&.&.&.&.&.\\\hline
 \end{tabular}
\end{center}
\begin{itemize}
 \item This game involves: Input/output, Vectors, File input, Data representation
 \item AI tips: Do not target the same cell twice, finish what you started
\end{itemize}


\subsection{4 in a row}

This game is played on a 6$\times$7 grid. Each player has to drop a token in one of the column, that will fall to the bottom or above potential existing tokens in this column.
The goal is to be the first to align 4 tokens, either vertically, horizontally or diagonally.
\begin{itemize}
 \item This game involves: Input/output, Vectors, Data representation
 \item AI tips: Do not let the other player align 4 token, or try to guess best possible choices for the next 1, 2, 10... turns.
\end{itemize}
\begin{center}
 \begin{tabular}{|c|c|c|c|c|c|c|}
 \hline  
 . &.&.&.&. &.&.\\\hline
 . &.&.&.&. &.&.\\\hline
 . &.&.&.&. &.&.\\\hline
 . &.&.&.&. &.&.\\\hline
 . &.&o&.&x &.&.\\\hline
 . &o&x&x&o &o&.\\\hline
 \end{tabular}
\end{center}


\section{Algorithms}

In this section, we program the computer to solve a given problem through an algorithm. Similarly to a cooking recipe, an algorithm is a sequence of basic steps (like finding the minimum value in a vector) that lead to an overall more complex behavior.

The problem data may be defined in a file or be randomly generated.
The use of the STL and of the \texttt{math.h} functions will be of good use. 

\subsection{Tower of Hanoi}

This one is a classical mathematical puzzle.
A given number of disks of different sizes are placed on three rods.
The only constraint is that a bigger disk cannot be above a smaller one. 

The goal is to move the disks one at a time (only the top disk of a rod may be moved to another rod) in order to have them all on a single rod.
The Wikipedia page will give you strong hints to solve this problem.

The starting position of the disks may be randomly generated or written in a file. The goal is of course to use a minimum number of moves.

\begin{itemize}
 \item This involves: File input, output, Vectors, Data representation, Recursive programming
 \end{itemize}
 
 \subsection{Robust fitting with Hough lines}
 
 This method will be taught in Computer Vision. We assume we have a number of $(x,y)$ points and want to find the line or lines that pass through them.
 A method was proposed by Hough and consists in finding all possible lines that pass through each point, and then count the similar lines. The ones that have
 the highest number of counts (or votes) are considered to be actual lines in the image.
 Do to so, we write a line equation as:
 \begin{equation*}
  x\cos\theta + y\sin\theta = \rho
 \end{equation*}We then consider a finite set of possible $\theta$ and $\rho$, typically:
 \begin{itemize}
  \item $\theta$ can go from $-\pi/2$ to $+\pi/2$ with 100 intermediary values
  \item $\rho$ can go from 0 to half the diagonal of the image with 100 intermediary values
 \end{itemize}
 We thus have a 100$\times$100 grid of all potential $(\rho,\theta)$ corresponding to 10000 lines.
 
 In practice, at the beginning of the program you can define $X$ as [-10, .., 10] and chose one, then two values for $(a,b)$.
 Then $Y$ is computed as $Y=aX+b$ and you have your set of X and Y coordinates. You can also add some random points to make it more difficult to the algorithm.
 
 The algorithm is given below.

 
\begin{algorithm}[!h]
\SetKwComment{Comment}{(}{)}
% \SetAlgoLined
\KwData {X and Y, min. votes n}
\KwResult {$(\rho,\theta)$ for best lines}
%add $P_0$ to $\mathcal{P}_s$\;
init $\rho_v$ and $\theta_v$ vectors from desired range and step\;
RT$\gets$zero matrix of dim. 100$\times$100\;
\For{i in range(100)}{
\For{(x,y) in (X,Y)}
{
$\rho\gets x\cos\theta_i + y\sin\theta_i$\;
j$\gets$index of $\rho_v$ nearest to $\rho$\;
RT[j,i]+= 1\;
}}
$(\rho,\theta)$ are the values where RT[i,j] $>$ n\;
\caption{Hough line detector}
\label{algo:hough}
\end{algorithm}

\begin{itemize}
 \item This involves: Output, Vectors, Sort and Find maximum (STL)
 \end{itemize}
 
 
 
 
 \subsection{Path planning with A*}
 
 The A* algorithm is a popular path planning method that can easily find the shortest path from a starting to a desired position in a graph. 
 A graph is a set of nodes (positions or situations) linked by elementary steps (for example, going from (0,0) to (0,1)). It may be a classical 2D or 3D space, but
 also any kind of graph where we want to find the shortest path. 
 
 \begin{itemize}
 \item This involves: File input, output, Vectors, Data representation, Sort and find minimum (STL), Classes, Inheritance, Templates or References
 \end{itemize}
 
 \subsubsection{General A* algorithm}
 The algorithm is based on two functions:
 \begin{itemize}
  \item The travel function $g(i)$ expresses the distance between the starting position and the evaluated one. 
  \item The heuristic function $h(i)$ tries to estimate the cost from the current position to the desired one. 
 \end{itemize}The total cost function is the sum of $g$ and $h$.
It is also using two sets of nodes:
\begin{itemize}
 \item The closed set regroups all nodes that have been evaluated (starts at empty)
 \item The open set regroups all nodes that are to be evaluated (starts with the initial position)
\end{itemize}


\begin{algorithm}[!t]
\SetKwComment{Comment}{(}{)}
% \SetAlgoLined
\KwData {start and goal positions}
\KwResult {Sequence of nodes that define the shortest path}
%add $P_0$ to $\mathcal{P}_s$\;
closedSet$\gets$ []\;
openSet$\gets$ [start]\;
inside $\gets$ true\; 
start.g$\gets$ 0\;
start.compute\_h(goal)\;
start.compute\_f()\;
\While{openSet not empty}{
candidate $\gets$ node in openSet with lowest f score\;
\If{candidate == goal}{
return candidate\;}

openSet.remove(candidate)\;
closedSet.add(candidate)\;
\For{each neighboor of candidate}{
union$\gets$openSet + closedSet\;
\eIf{neighboor is in union}
{
twin$\gets$neighboor from union set \;
\If{twin.g $>$ neighboor.g}{
twin.set\_parent(candidate)\;
twin.compute\_f()\;
openSet.add(twin)\;
}
}
{
neighboor.compute\_h(goal)\;
neighboor.compute\_f\;
openSet.add(neighboor)\;
}
}

}
\caption{A* algorithm}
\label{algo:smallpoly}
\end{algorithm}

As we see, the algorithm does not depend on the type of the nodes, as long as the following can be defined:
\begin{itemize}
 \item The $h$ function from the node to the goal
 \item The $neighboor$ function that gives the nearest nodes to the current node (\texttt{vector}?)
 \item The $==$ operator that checks whether two nodes are the same
\end{itemize}

This is perfect for classes as the actual algorithm can be written in a generic way. I suggest you write it for a given class to test it without using templates.


\subsubsection{Classical 2D path planning}

This first A* problem consists of a 20$\times$20 grid where a robot must go from $(0,0)$ to $(19,19)$.
Obstacles exist of course in the grid. They can be defined randomly or in a text file that the program will read.
In this case:
\begin{itemize}
 \item The $h$ function is the Euclidean distance to the goal.
 \item The $neighboor$ function should give all the nodes reachable from a $\pm1$ move on x or y.
 \item The $==$ operator corresponds to having equal x and y.
\end{itemize}

\subsubsection{The 8-puzzle or 15-puzzle problem}

In this problem, we have a 3$\times$3 grid with cells numbered from 1 to 8\footnote{can also be done on a 4$\times$4 grid with numbers 1..15}, and an empty cell.
The goal is to reach the following configuration:
\begin{center}
 \begin{tabular}{|c|c|c|}
 \hline  
 1 &2&3\\\hline
 4 &5&6\\\hline
 7&8&.\\\hline
 \end{tabular}
\end{center}
We go from one position to another one by sliding one cell in the empty cell. For example, the two configurations that may lead to the desired one are:
\begin{center}
 
 \begin{tabular}{|c|c|c|}
 \hline  
 1 &2&3\\\hline
 4 &5&6\\\hline
 7&.&8\\\hline
 \end{tabular}\quad\quad\quad
 \begin{tabular}{|c|c|c|}
 \hline  
 1 &2&3\\\hline
 4 &5&.\\\hline
 7&8&6\\\hline
 \end{tabular}
\end{center}

In this case:
\begin{itemize}
 \item The $h$ function can be the Manhattan distance, that is:
 \begin{equation*}
  h(x,y) = \sum_{i=1}^8(|x_i - x_i^*| + |y_i - y_i^*|)
 \end{equation*}where $(x_i,y_i)$ is the position of cell $i$ in the grid and $(x_i^*,y_i^*)$ is the position
 of cell $i$ in the desired grid.
 \item The $neighboor$ function should give all the grids reachables from the current one.
 \item The $==$ operator corresponds to having the cells at the same positions.
\end{itemize}

Note that not all starting grids can reach the desired one. The best way to build a starting position is to start from the desired one and randomly move cells
for 30 to 40 steps. The algorithm will usually find a much shorter path to come back.



\section{Genetic algorithms}





 









\end{document}
